#include <iostream>
using namespace std;

// 오늘 주제는 정적 변수와 상수 변수

// 정적 변수 생성
void func(){
    int a = 10;
    static int b = 10;

    a++;
    b++;

    cout << "a = " << a << " b = " << b << endl;
}

int main(){

    // 여기서부터 정적 변수
    // 지역 변수는 해당 블록이 끝나면 소멸한다. (자동 지속)
    // 하지만 지역 변수에 static 키워드를 사용하면 자동 지속에서 정적 지속으로 변수의 유효 범위가 바뀐다.
    // 이렇게 생성된 정적 변수는 선언된 블록이 끝나도 값을 유지한다.

    func(); // a = 11, b = 11
    func(); // a = 11, b = 12
    func(); // a = 11, b = 13
    func(); // a = 11, b = 14
    func(); // a = 11, b = 15
    func(); // a = 11, b = 16
    func(); // a = 11, b = 17
    // a와 b의 값이 계속 차이가 나게 되는 이유는 
    // a는 지역 변수라 func 함수가 호출될 때 마다 새로 생성되고, 
    // func 함수가 종료되면 소멸한다. (자동 지속)
    // 하지만 b는 정적 변수로 선언되어 func 함수가 종료되어도 사라지지 않고
    // func 함수가 호출된 만큼 값이 누적된다.
    // 그래도 매번 호출될 때 마다 값이 10으로 초기화될 것 같지만,
    // 정적 변수는 딱 한번만 초기화되며, 프로그램이 종료할 때까지 값이 계속 지속된다.
    // 그렇기 때문에 static으로 정적 변수를 선언할 때는 반드시 초기화해야 한다.
    // 초기화하지 않으면 컴파일러가 0으로 자동으로 초기화한다.
    // 그리고 정적 변수는 메모리의 데이터 영역에 할당되기 때문에
    // 프로그램이 종료될 때까지 값이 유지되는 것이다.
    // 정적 변수를 사용할 때는
    // 클래스나 함수의 모든 인스턴스 간에 공유되는 변수를 선언하고 싶지만
    // 해당 클래스나 함수 밖에서 보이지 않게 하고 싶을때 사용한다.
    // 예를 들어 객체를 생성할 때마다 1씩 증가시켜서 얼마나 많은 객체를 생성했는지 센다거나..

    // 그리고 정적 변수는 데이터 영역에 저장되기 때문에 절대 값의 주소(포인터)가 바뀌지 않는다.
    // 그래서 멀티 스레드 프로그래밍을 할 때는 모든 스레드가 이 하나의 주소를 노리기 때문에 
    // 웬만하면 추가적으로 원자적(Atomic) 변수로 선언하는게 안전하다.
    // 아니면 따로 동기화 도구(뮤텍스, 세마포어, 모니터 등)를 사용하거나..

    // 여기서부터는 상수 변수
    // 상수 변수란 말그대로 '상수', 변하지 않는 값
    // 상수 변수를 선언할 때는 반드시 초기화해야 한다. 아니면 컴파일 에러 발생.
    // 그리고 물론 변하지 않는 값이기 때문에 상수 변수에 새로운 값을 넣으려 하면 컴파일 에러 발생.
    const int constant = 1; // 초기화 하지 않으면 컴파일 에러 발생
    // constant = 2; 새로운 값을 대입하려 하면 컴파일 에러 발생

    // 물론 포인터 변수도 상수 변수로 선언할 수 있다.
    int k = 10;

    // 특이한 점으로, const 키워드의 위치에 따라 상수화할 대상이 달라진다.
    const int *ptr1 = &k;
    k = 1; // 포인터 변수인 ptr1이 가리키는 k 변수 자체는 상수회되지 않는다. 포인터 변수만 상수화 됨.
    // *ptr1 = 2; 하지만 포인터 변수가 가리키는 값은 상수화가 된다.
    

    int *const ptr2 = &k;
    int c = 100;
    ptr1 = &c;
    k = 3; // 물론 여기서도 포인터 변수인 ptr2가 가리키는 변수인 k 자체는 상수회되지 않는다.
    // ptr2 = &c 하지만 여기서는 포인터 변수 자체가 상수회되어, 
    // 다른 일반 변수인 c의 주소로 포인터 변수의 값을 변경할 수 없게 된다.

    // 그리고 포인터 변수가 가리키는 값과 포인터 변수 자체를 둘 다 변경하지 못하게 하려면 이렇게 선언하면 된다.
    const int *const ptr3 = &c;

    // 요약하면,
    // 포인터 변수를 상수 변수로 선언할 때,
    // const int *ptr = &a; 형식으로 선언하면 포인터 변수가 가리키는 값을 상수화 하는 것이고,
    // int *const ptr = &a; 형식으로 선언하면 포인터 변수 자체를 상수화 하는 것이다.

    // 어쨌든 키워드 const가 붙으면 해당 변수는 변경할 수 없는 상수 변수가 된다.
    return 0;
}