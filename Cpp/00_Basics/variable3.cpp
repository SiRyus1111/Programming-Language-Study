#include <iostream>
#include <bitset>
using namespace std;

// 오늘 주제는 표현식과 연산자
int main(){
    
    int n;
    int a = 7;
    int b = 2;
    // 표현식 예시
    // = 은 대입 연산자, +는 산술연산자
    // n, a, b는 피연산자
    n = a + b;

    // 상수 표현식
    // 상수로만 이뤄진 단순한 표현식
    int p = 1;
    char s = 'c';



    int k = 1;
    int k2 = 1;
    cout << "k(증감 연산 전) = " << k << endl;
    
    // 여기서부터 단항 연산자(연산에 참여하는 피연산자가 1개)
    
    // 증감 연산자(전위/후위)
    // (++변수, 변수++, --변수, 변수--)
    // 후위 증감 연산자(값++, 값--)는 대입 연산 후 값 1 증가/감소
    // 전위 증감 연산자(++값, --값)는 값 1 증가/감소 후 대입 연산
    int i = k++;
    cout << "i(후위 증감 연산) = " << i << endl;
    
    int j = ++k2;
    cout << "j(전위 증감 연산) = " << j << endl;
    
    // 논리 NOT 연산자
    // (!피연산자)
    // true는 false로, false는 true로 반전
    bool l = true;
    bool r = !l;
    cout << "l(원래 변수 l) = " << l << endl;
    cout << "r(논리 NOT 연산 후 변수 l) = " << r << endl;

    // 비트 NOT 연산자
    // (~피연산자)
    // 피연산자를 이진수로 표현했을 때 0과 1을 뒤집는다.
    int v = 0x00000000;
    cout << "v(비트 연산 전) = " << v << " (16진수로 00000000이다)" << endl;
    v = ~v;
    cout << "v(비트 연산 후) = " << v << " (16진수 00000000의 비트의 0과 1을 뒤집어서 ffffffff이다.)" << endl;

    // 추가로 포인터 연산자(*변수)와 주소 연산자(&변수)도 있지만, 
    // 이건 다음에 포인터 배울 때 배운다.

    // 이항 연산자 (연산에 참여하는 피연산자가 2개)

    // 산술 연산자
    // (피연산자1 = 피연산자2, 피연산자1 + 피연산자2, 피연산자1 - 피연산자2, 피연산지1 * 피연산자2, 피연산자1 / 피연산자2, 피연산자1 % 피연산자2)
    // =는 대입, +는 더하기, -는 빼기, *는 곱하기, /은 나눗셈의 몫 구하기, %는 나눗셈의 나머지 구하기
    cout << "a = " << a << endl;
    cout << "b = " << b << endl;
    cout << "a + b = " << a + b << endl; // 더하기
    cout << "a - b = " << a - b << endl; // 빼기
    cout << "a * b = " << a * b << endl; // 곱하기
    cout << "a / b = " << a / b << endl; // 나눗셈의 몫
    cout << "a % b = " << a % b << endl; // 나눗셈의 나머지

    // 관계 연산자(피연산자 1 기준)(변수1이 변수2보다~)(조건식)
    // (피연산자1 == 피연산자2)(같음) 
    // (피연산자1 != 피연산자2)(같지 않음) 
    // (피연산자1 <= 피연산자2)(작거나 같음) 
    // (피연산자1 >= 피연산자2)(크거나 같음) 
    // (피연산자1 < 피연산자2)(작음)
    // (피연산자1 > 피연산자2)(큼)
    // 두 피연산자의 관계가 참이냐 거짓이냐에 따라 true, false 반환
    bool ab = a == b;
    // a와 b는 같지 않으므로 false 반환
    cout << "a와 b가 같은지 = " << ab << endl;

    // 논리 연산자(AND, OR)
    // 조건식1 && 조건식2(AND, 조건1과 조건2 모두 참일 때 true, 아니면 false), 
    // 조건식1 || 조건식2(OR, 조건1과 조건2 중 하나라도 참일 때 true, 둘 다 거짓이면 false)
    bool bc = true;
    cout << "ab = " << ab << endl;
    cout << "bc = " << bc << endl;
    cout << "ab && bc = " << (ab && bc) << endl;
    cout << "ab || bc = " << (ab || bc) << endl; 

    // 비트 연산자(AND, OR, XOR, 비트 시프트)
    // (피연산자1 & 피연산자2)(피연산자1과 피연산자2의 비트를 비교해서 둘 다 1인 자리는 1 하나라도 1이 아닌 자리는 0을 반환)
    // (피연산자1 | 피연산자2)(피연산자1과 피연산자2의 비트를 비교해서 둘 중 하나라도 1인 자리는 1 둘 다 1이 아닌 자리는 0을 반환)
    // (피연산자1 ^ 피연산자2)(피연산자1과 피연산자2의 비트를 비교해서 다른 자리는 1, 같은 자리는 0을 반환)
    cout << "a(4비트) = " << bitset<4>(a) << " : " << a << endl;
    cout << "b(4비트) = " << bitset<4>(b) << " : " << b << endl;
    cout << "a & b = " << bitset<4>(a & b) << " : " << (a & b) << endl;
    cout << "a | b = " << bitset<4>(a | b) << " : " << (a | b) << endl;
    cout << "a ^ b = " << bitset<4>(a ^ b) << " : " << (a ^ b) << endl;
    
    // 비트 시프트(밀기) 연산자 (왼쪽 시프트, 오른쪽 시프트)(산술/논리 시프트 연산)
    // (피연산자 << 이동 비트 수)(피연산자의 비트를 이동 비트 수만큼 왼쪽으로 시프트(밀기)) 
    // (피연산자 >> 이동 비트 수)(피연산자의 비트를 이동 비트 수만큼 오른쪽으로 시프트(밀기))
    // 논리 시프트 연산은 오른쪽 왼쪽 시프트 모두 시프트 후 빈 자리에 0을 채움
    // 산술 시프트 연산은 왼쪽 시프트는 논리 시프트 연산과 같으나 오른쪽 시프트 후에는 맨 앞 빈 자리에 원래의 부호 비트와 같은 숫자를 채움
    // signed(-범위가 있는) 자료형에서는 최상위 비트(맨 왼쪽 비트)가 부호를 판별하는데 쓰이므로, 
    // 산술 시프트 연산에서 부호 비트를 유지하기 위해 오른쪽 시프트 후에 맨 앞 빈 자리에 부호 비트와 같은 숫자를 채우고 다른 빈 자리에는 0을 채움
    int x = 13;
    int y = -13;
    cout << "x(8비트) = " << bitset<8>(x) << " : " << x << endl;
    cout << "x << 1(x를 왼쪽으로 1비트만큼 논리/산술 시프트) = " << bitset<8>(x << 1) << " : " << (x << 1) << endl;
    cout << "x >> 1(x를 오른쪽으로 1비트만큼 산술 시프트, 양수이므로 부호 비트는 0) = " << bitset<8>(x >> 1) << " : " << (x >> 1) << endl;
    cout << "y >> 1(y를 오른쪽으로 1비트만큼 산술 시프트, 음수이므로 부호 비트는 1 이고 2의 보수(0과 1을 바꾼 후 1을 더한 수)) = " << bitset<8>(y >> 1) << " : " << (y >> 1) << endl;

    // 삼항 연산자(연산에 참여하는 피연산자가 3개)
    
    // (조건식 ? 참일 때 표현식 : 거짓일 때 표현식)
    // (조건식이 참일 때와 거짓일 때의 표현식을 조건식이 참일 때는 참일 때의 표현식, 조건식이 거짓일 때는 거짓일 때의 표현식을 실행함)
    cout << "(x == -y) ? 5 : 3 = " << ((x == -y) ? 5 : 3) << endl; // x(13) == -y(13)이므로 참일 때의 표현식인 5를 출력
}