#include <iostream>
using namespace std;

// 오늘 주제는 동적 메모리 할당
int main(){
    
    // 이렇게 배열의 크기를 5로 설정해 놓으면,
    // 최대 5개의 원소만 들어갈 수 있다.
    // 그래서 더 많은 원소가 필요할 때는 처리할 수 없다.
    int arr1[5] = {1, 2, 3, 4, 5};
    
    // 그렇다고 이렇게 배열의 크기를 너무 크게 설정해 놓으면,
    // 메모리가 낭비될 수 있다.
    int arr2[100];

    // 이럴 때 동적 메모리 할당을 사용한다.

    // 동적 메모리 할당이란, 
    // 프로그램 실행 중에도
    // 필요한 크기의 메모리를 운영체제에 요청하여
    // 사용할 수 있는 방법이다.
    
    // 이렇게 new 연산자를 이용해 동적 메모리를 할당한다.
    // new 연산자는 요청한 타입(예시에서는 int)만큼의 메모리를 할당하고, 
    // 그 (시작) 주소(포인터)를 반환한다.
    // 자료형 *변수_이름 = new 자료형;
    
    int *int_value_pointer = new int; // int 타입 크기의 메모리 할당
    
    // 정수(int형)를 저장할 메모리 주소를 동적 할당하고
    // *로 포인터 변수를 선언해서 
    // 해당 메모리 공간의 (시작) 주소를 변수 int_value_pointer가 가리키게 한다.
    // (new 연산자가 메모리 주소를 반환하므로 포인터 변수를 사용해야한다.)

    *int_value_pointer = 100; // 변수 int_value_pointer가 가리키는 메모리 공간에 100을 추가
    cout << "동적 할당된 메모리 공간에 추가한 데이터 = " << *int_value_pointer << endl;
    
    // 만약 new 연산자로 할당된 메모리가 필요 없어진다면
    // 이렇게 delete 연산자로 반드시 직접 할당된 메모리를 해제해야 한다.
    // 할당된 메모리를 해제해야 하는 이유는 후술한다.
    // delete 변수_이름;
    delete int_value_pointer;

    // 변수 하나가 아니라 변수 여러개가 있는 배열도 
    // 동적 메모리 할당을 할 수 있다.
    // 자료형 *배열_이름 = new 자료형[크기];
    int *int_array_pointer = new int[5]; // 동적 메모리 할당(배열)

    for (int i = 0; i < 5; i++){
        int_array_pointer[i] = i; // 동적 메모리가 할당된 배열 변수에 0~4 순서대로 넣기
    }
    for (int i = 0; i < 5; i++){
        cout << "int_array_pointer[" << i << "] = " << int_array_pointer[i] << endl; // 배열의 변수들 출력
    }

    // 배열이 할당된 메모리를 해제하려면 delete가 아니라
    // 반드시 delete[]를 사용해야한다.
    delete[] int_array_pointer;

    // 그런데 왜 동적 할당 메모리를 해제해야할까?
    // 대부분의 일반 변수는 스택 영역에 함수의 호출과 함께 할당되며,
    // 함수가 반환되면 자동으로 소멸한다.
    // 그래서 굳이 지역 변수 같은 일반 변수는 
    // 일일히 메모리 해제를 관리할 필요가 없다.
    // 그리고 스택 영역은 크기가 한정되어있어서, 
    // 이 크기를 초과하면 운영체제가 해당 프로세스를 강제로 종료시킨다.
    
    // 그리고 동적으로 할당된 변수는 메모리의 힙 영역에 할당된다.
    // 힙은 스택보다 훨씬 큰 메모리 풀이기 때문에
    // 크기가 큰 배열도 충분히 할당할 수 있다.
    // 하지만 스택 영역과 다른 점이 있는데,
    // 바로 개발자가 명시적으로 해제하기 전에는 
    // 해당 프로세스가 종료될 때까지 계속 유지된다는 점이다.
    // 그래서 메모리 해제를 적절히 하지 않으면, 
    // 프로세스가 실행되면서 조금씩 메모리 누수가 누적된다.
    // 그러면 딱히 돌아가는 것도 없는데 메모리가 상당히 차 있는 문제가 발생할 수 있다.
    // 게임을 하다가 컴퓨터가 느려지거나 멈추는 현상은 이러한 메모리 누수가 원인일 수 있다.


    // 추가로 포인터를 다룰 때의 주의할 점에 대해서 알아보자.
    
    // 첫 번째로, *변수_이름 = 값 처럼 포인터를 역참조하기 전에 
    // 포인터가 유효한 메모리를 가리키는지 확인해야한다.
    // 그렇지 않으면 세그멘테이션 실패(허용되지 않은 메모리 영역에 접근할 때 발생)나 
    // 런타임 오류가 발생할 수 있다.

    // 두 번째로, 할당된 메모리의 범위를 벗어나는 포인터 연산은 하면 안된다.
    // 예를 들어, 문자 5개로 이루어진 배열 arr이 있다고 하고,
    // 배열 arr의 첫 번째 원소를 가리키는 포인터 변수를 선언했다고 하자.
    // 근데 포인터 연산으로 배열 arr의 6번째 원소에 접근하려고 하면,
    // 해당 배열에 할당되지 않은 메모리에 접근하게 된다.
    // 그렇다면 의도를 벗어난 동작이 발생할 수 있다.

    // 마지막으로, 할당 해제된 메모리를 역참조하면 안된다.
    // 이미 변수 a를 가리키는 메모리를 할당 해제했는데,
    // 변수 a를 가리키는 포인터 변수를 역참조하려 하면
    // 의도를 벗어난 동작이 발생할 수 있다.
}