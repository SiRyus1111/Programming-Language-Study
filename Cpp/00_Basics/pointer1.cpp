#include <iostream>
using namespace std;

//오늘 주제는 포인터
int main(){
    
    // 포인터 = 메모리 주소를 저장하는 변수
    int n = 10; // 4바이트 크기(메모리를 4바이트만큼 차지)
    char c = 'A'; // 1바이트 크기(메모리를 1바이트만큼 차지)

    // 포인터는 데이터가 어디서부터 저장되어있는지를 알려주는 시작 메모리 주소를 저장한다.
    
    // 포인터 변수 선언
    // 자료형과 변수명 사이에 *를 추가해서 선언한다.
    // 사실 포인터 변수의 크기는 데이터 형식과는 관련이 없지만
    // (어떤 형식의 데이터의 포인터 변수든 8바이트 공간만 차지),
    // 굳이 데이터 형식을 지정하는 이유는 
    // 해당 포인터가 가리키는 메모리 주소에 저장되어있는 데이터의 형식을 명시하기 위해서다.
    // 이렇게 포인터 선언문에 지정한 형식으로 해당 포인터가 가리키는 데이터의 크기와 해석 방법이 결정된다.
    // 포인터를 대상으로 연산할 때 필요하고, 
    // 포인터를 사용하는 코드에서 데이터 형식의 일관성을 유지하고 오류를 방지하는데 도움이 된다.
    int *n_pointer;

    // 포인터 변수에 주소 대입
    // &는 피연산자의 주소를 읽어 오는 주소 연산자 
    // (&피연산자)
    n_pointer = &n;

    // 포인터 변수 초기화
    char *c_pointer = &c;

    // 실제로 메모리 주소가 포인터 변수에 들어가있다
    cout << "n_pointer = " << n_pointer << endl;
    // 실제로는 c_pointer 변수에 변수 c의 메모리 주소값이 저장되어 있지만, 
    // cout가 실제로 보여주는건 그 주소에 저장되어있는 값이다.
    // 그리고 이건 나중에 더 배울 예정이다.
    cout << "c_pointer = " << c_pointer; 
    // 실제로 주소를 출력하고 싶으면 이렇게 하면 된다..(void* 형으로 형변환)
    // (여기서의 void*를 쉽게 말하면, 타입을 정하지 않은 순수한 메모리 주소 그 자체를 나타낸다.)
    // 이건 나중에 더 자세히 살펴보자. 
    // 지금은 일단 메모리 주소를 출력하고 싶었기 때문에 이걸 먼저 한번 해봤다.
    cout << "(void*)c_pointer = " << (void*)c_pointer << endl;

    // 포인터 변수를 이용해서 일반 변수의 값을 가져오려면 어떻게 해야할까?
    // 일단 일반 변수의 데이터 출력(저장된 값 확인용)
    cout << "n = " << n << endl;
    cout << "c = " << c << endl;
    
    // 포인터 변수가 가리키는 데이터의 접근하기(역참조 연산자 * 사용)
    // 이렇게 포인터 변수에 역참조 연산자 *를 사용하면 
    // 해당 포인터 변수에 저장된 주소가 가리키는 데이터에 접근할 수 있다.
    cout << "*n_pointer = " << *n_pointer << endl;
    cout << "*c_pointer = " << *c_pointer << endl;

    // 물론 원본 데이터를 덮어쓸 수도 있다.
    *n_pointer = 123;
    cout << "n = " << *n_pointer << endl;
    *c_pointer = 'K';
    cout << "c = " << *c_pointer << endl;

    // 다중 포인터
    // 포인터 변수의 주소도 포인터 변수에 저장할 수 있다
    int **n_n_pointer = &n_pointer;
    cout << "n_n_pointer = " << n_n_pointer << endl;
    cout << "n_pointer = " << n_pointer << endl;
    // 역참조 연산자를 N중 포인터일 때 N만큼 사용하면 원래 값이 저장되어있는 일반 변수에 접근할 수 있다.
    cout << "n_n_pointer의 값으로 n의 값을 출력 = " << **n_n_pointer << endl;

    // 배열과 포인터
    // 포인터와 배열은 뗄레야 뗄 수 없는 관계다.
    int arr[5] = {1,2,3,4,5};
    // 메모리 주소를 출력하면, int 자료형이 4바이트의 공간을 사용하기 때문에 
    // 각 인덱스의 주소가 시작 주소(arr[0])으로부터 4씩 증가한다.
    for (int i = 0; i<5; i++){
        cout << "arr[" << i << "] Address = " << &arr[i] << endl;
    }
    // 이걸 이용하면, 이런게 된다.
    // 배열의 n번 인덱스에 접근하는 방식은 arr[n]뿐만이 아니다.
    // arr + n의 방식으로도 가능하다.
    // 이 방식은 포인터 연산으로 배열의 각 인덱스에 접근하는 방식이다.
    // 이게 왜 되냐면, 배열의 이름인 arr이 첫 번째 인덱스의 주소(&arr[0])을 가리키고 있기 때문이다.
    // 그리고 왜 4의 배수가 1의 배수를 더하냐면, 
    // 포인터 연산에서 덧셈은 자료형의 크기를 곱한 만큼 덧셈을 수행하기 때문이다.
    for (int i = 0; i<5; i++){
        cout << "arr[" << i << "] Address = " << &arr[i] << endl; // 여기와
        cout << "arr + " << i << " Address = " << arr + i << endl; // 여기의 주소가 같다!
        cout << "arr[" << i << "] = " << arr[i] << endl; 
        cout << "arr + " << i << " = " << *(arr + i) << endl; 
    }

    // 그렇다고 배열과 포인터가 같지는 않다.
    int *arr_pointer = arr;
    
    // arr과 arr_pointer가 같은 주소를 가리키고 있지만,
    cout << "arr Address = " << arr << endl;
    cout << "arr_pointer = " << arr_pointer << endl;
    
    // 크기는 다르다.
    // arr는 int[5] 형식, arr_pointer는 int* 형식이기 때문이다.
    // int는 4바이트, 5개의 인덱스가 있으니 4 * 5 = 20바이트
    // 포인터 변수(int*) = 8바이트
    cout << "sizeof(arr) = " << sizeof(arr) << endl;
    cout << "sizeof(arr_pointer) = " << sizeof(arr_pointer) << endl;

    // 배열과 포인터의 관계에서 핵심은 배열의 원소에 접근할 때,
    // 포인터 연산으로도 가능하다는 것이다.

    return 0;

}